# Тренинг «Unit Testing & TDD»
24 ак. часа, 18 астр. часов

# Цели тренинга
После тренинга участники смогут:
1. Объяснить себе и менеджменту, где им нужны тесты, а где нет
1. Разрабатывать поддерживаемые тесты и их наборы
1. Разрабатывать тесты как «спецификации на примерах» в роли документации
1. Подменять сложные компоненты системы на время тестирования
1. Анализировать тестовое покрытие для принятия решений по тест-дизайну
1. Обеспечивать поддерживаемый дизайн системы при помощи TDD
1. Обеспечивать в проекте контролируемый cycle time задач
1. Обеспечивать в проекте контролируемое качество системы

# Программа
## 1. Зачем мы собрались? (0.5 часа всего / _из них_ 0.25 часа практики и обсуждений)
1. Обзор тренинга
1. Знакомство и сбор проблем
1. Разбивка по парам

## 2. Как обеспечить качество продукта? (0.5/0.25)
1. Что такое качество?
1. Какие способы обеспечения качества существуют?
1. Каковы их ограничения?

## 3. Что можно тестировать? (0.5/0.25)
1. Модель качества: FRs & NFRs
1. Системные тесты
1. Интеграционные тесты
1. Модульные тесты
1. Их ценность и затраты?
1. Как по коду определить скоуп?

## 4. Что такое автотест? (0.5/0)
1. Каковы цели и задачи _авто_тестов?
2. В чем отличие от отладки?
3. Определение модуля и возможные виды модулей
4. Понятие контракта по Б. Мейеру
5. Понятие трасс выполнения (flows)
6. Граничные условия
7. Тест = спецификация

## 5. Какова структура автотеста? (0.5/0)
1. [Подключение основного фреймворка](https://github.com/junit-team/junit4/wiki)
1. Именование тест-кейса и теста
1. Подход AAA
1. Подход GWT из BDD
1. Роль фикстуры
1. [Забытый полуторный этап](https://github.com/junit-team/junit4/wiki/Assumptions-with-assume)

## 6. Как ускорить разработку автотестов за счет готовых фреймворков и библиотек? (2/1)
1. Подключение вспомогательных фреймворков
1. Простые сравнения средствами основного фреймворка
1. [Типизированные сравнения средствами встроенного фреймворка](https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat)
1. [Типизированные сравнения средствами отдельного фреймворка](https://github.com/alexruiz/fest-assert-2.x/wiki/One-minute-starting-guide)
1. [Таймауты](https://github.com/junit-team/junit4/wiki/Timeout-for-tests)
1. [Исключения](https://github.com/junit-team/junit4/wiki/Exception-testing)
1. [Параметризованные тесты](https://github.com/junit-team/junit4/wiki/Parameterized-tests)
1. Расширение поведения тестов с помощью [запускальщиков](https://github.com/junit-team/junit4/wiki/Test-runners) и [правил](https://github.com/junit-team/junit4/wiki/Rules)

## 7. Как писать интеграционные и модульные тесты? (2/1)
1. В чем их специфика?
1. Виды тест-дублеров
1. State-based testing VS Interaction-based testing
1. [Фреймворк тест-дублеров уровня объектов](https://site.mockito.org)
1. [Фреймворк тест-дублеров уровня REST-сервисов](http://wiremock.org/docs/getting-started/)
1. Как среда сборки различает UT и IT

## 8. Реализация фикстуры (1/0.5)
1. Как максимально реюзать фикстуры?
1. Наследование тест-кейсов
1. [Методы фреймворка](https://github.com/junit-team/junit4/wiki/Test-fixtures)
1. Fixture Builders

## 9. Как группировать тесты в наборы? (1/0.5)
1. Зачем нужны test suites?
1. Способы группировки "из коробки" фреймворка: [группы](https://github.com/junit-team/junit4/wiki/aggregating-tests-in-suites) и [категории](https://github.com/junit-team/junit4/wiki/Categories)
1. Способ группировки от среды сборки

## 10. Как замерять тестовое покрытие? (1/0.5)
1. Понятие покрытия
1. Виды расчета покрытия
1. Инструменты расчета покрытия
1. Что покрывать?
1. Анализ текущего покрытия

## 11. Как поддерживать качество тестов и снижать дублирование? (1/0.5)
1. Как обеспечить качество самих тестов?
1. Сначала поломанный тест
1. Анализ тестового покрытия
1. Ревью кода тестов
1. Mutation coverage

## 12. Анти-паттерны разработки модульных тестов (0.5/0.5)
1. Каковы "вредные советы"?
1. Отношение к тестам не как к обычному коду
1. Большие расфокусированные тесты
1. Неговорящие имена
1. Дублирование фикстуры
1. Стопроцентное покрытие

## 13. Как обеспечить тестопригодность дизайна системы? (1/0)
1. Как оценить тестопригодность?
1. Метрика Coupling
1. Метрика Cohesion
1. Каков тестопригодный дизайн?
1. Принципы проектирования SOLID
1. Шаблоны Factory и DI
1. Шаблоны Strategy/State

## 14. Как покрывать тестами legacy code? (0.5/0)
1. Какие выделяем проблемы с тестопригодностью?
1. Ключевая диллема покрытия legacy code

## 15. Какую ценность дает практика TDD? (0.5/0)
1. Что такое TDD?
1. TDD как практика проектирования
1. Зачем нужен TDD?
1. Минимизация отладки
1. Снижение затрат на инкрементальную разработку
1. Быстрая обратная связь
1. Повышение поддерживаемости дизайна
1. Удобство API "из коробки"
1. Тесты как документация
1. Предсказуемость поставки
1. Чистый работающий код
1. Управление страхом

## 16. В каком ритме писать по TDD? (0.5/0)
1. Red – Green – Refactor
1. Демо
1. Скорость отработки тестового набора как предусловие практики TDD

## 17. Как инкрементально проектировать и разрабатывать систему? (1/0.5)
1. Инкрементальная реализация трасс через покрытие граничных условий
1. Дублирование тестов в классах эквивалентности

## 18. [Базовые шаблоны TDD](https://www.dropbox.com/s/iiip3qdny3wwuyd/00.jpg?dl=0) (1/0.5)
1. Test First
1. Isolated Tests
1. Assertion First
1. Test Data
1. Child Test
1. Test List
1. Mock Object
1. Crash Test Dummy

## 19. Шаблоны красной и зеленой полосы (1/0.5)
### Красной полосы
1. One-step Test
1. Starter Test
1. Another Test
1. Regression Test

### Зеленой полосы
1. Obvious Implementation
1. Triangulation
1. One to Many

## 20. Как внедрить TDD в процесс разработки? (0.5/0)
1. Каковы затраты на TDD?
1. Постановка экономической задачи
1. Как внедрить?
1. Общение с менеджментом
1. Secure sandbox
1. Последовательное расширение scope

## 21. Типовые ошибки использования TDD (0.5/0)
1. Code First
1. Too Many Obvious Implementation
1. Too Many Triangulations
1. Coverage Affinity
1. Implementation Testing but not Contract Testing

## 22. Финальная ретроспектива (0.5/0.5)
